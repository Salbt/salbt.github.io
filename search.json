[{"title":"币安钱包运作原理","path":"/2024/05/28/币安钱包运作原理/","content":"加密钱包加密货币钱包是一种与区块链网络进行交互的工具，可以用于区块链各网络的转账交易、合约交互和密钥管理等功能。 常见加密货币钱包分为三类： 软件钱包：用户通过应用软件管理密钥和于区块链的交互，其类型又可以分为：桌面端钱包、网络钱包、移动端钱包。可以简单的理解这三种类型的钱包。 桌面端钱包是下载到本地计算机的软件 网络钱包多是浏览器的扩展件 移动钱包是为智能手机量身定做的软件 硬件钱包：硬件钱包是一种实体电子设备，使用随机数生成器(RNG)生成公钥以及私钥。 纸钱包：通过物理方式将将密钥和地址记录在纸上或其他物理实体上，但这种方式无疑是过时的（某种意义上讲，只要保管的好就能保存很久——纸只要不受潮能比硬件设备寿命得还久…） 根据其工作机制，还可将其分为热钱包或冷钱包。一般通过是否与网络连接来区分钱包是冷钱包还是热钱包。 冷钱包和热钱包冷钱包是一种不会连接网络，也不会于任何智能合约交互的加密钱包。一般冷钱包是存放在离线的电子设备上，比如：Ledger 售卖的设备、安装移动端钱包的不联网手机都是冷钱包（冷钱包不等于硬件钱包，硬件钱包可以是冷钱包） 冷钱包不会连接网络其私钥对于网络来说是保持离线状态的，所以冷钱包很难遭受到黑客的攻击 由于冷钱包的安全性，它适合用于大额代币的资产存储 冷钱包只能转账不会与智能合约交互，这可以保证钱包避免恶意合约带来的损失 冷钱包通过与你自己的热钱包签署交易进行转账 热钱包是与区块链网络连接进行交易或与合约交互的加密钱包。与冷钱包相比，热钱包具有更多的灵活性，它可以随时向网络发送交易和与合约交互，所以它需要保持与网络连接。网络钱包和移动端钱包多是热钱包，比如：metamask、okt、coinbase等 热钱包需要连接网络，黑客可以通过网络侵入你的设备盗取私钥 热钱包适合日常使用和小额交易 冷钱包由于其离线的特性，它不能查看到自己钱包中的余额。但是可以通过热钱包查询到冷钱包的余额 可以使用热钱包与冷钱包的组合，既能保证交易的灵活性也能保证钱包的安全性 币安钱包管理体系 大型加密资产交易平台的钱包管理体系异常复杂，以至于大多数人都无法理解。币安通过冷热钱包动态运行来确保必要的流动性，以实时满足每个订单的需求，同时减少潜在的安全性威胁。币安钱包管理系统的两大特点（流动性和安全性）是币安钱包运行的两大基础。 币安冷热钱包运作体系用户可以可以在各个区块链上向充值钱包充值加密货币，币安则通过监控区块链来获取用户的余额情况。 Consolidation——归集在完成链上认证后，币安会每隔一段时间将这些代币转移到其拥有的热钱包或冷钱包（在网络gas较低时进行转移）。这种将代币转移到综合*(omnibus)*热钱包的过程称为归集 币安会积累大量金额后进行转移 归集不会影响用户存取 通过*”归集”*流程整合热钱包中的资金可以确保快速、低成本地满足提现请求。 溢出和补充币安通过overflow（溢出）和top-up（补充）进行冷热钱包之间资金流转。 溢出是指多余资金将从热钱包流转到冷钱包或线下钱包等安全的储存介质中。 归集获得的大额资金时，会将部分资金从热钱包转移到冷钱包中。这种方式能增强资金的安全性 补充是指热钱包需要补充资金，将冷钱包的资金装转移到热钱包中。 用户向热钱包发起大额资金提现时，热钱包会从冷钱包补充资金。这种方式可以保证资金的流动性 PoR储备金证明保证币安资金透明性PoR——储备量证明，币安通过展示证据证明币安拥有覆盖所有用户资产 1:1 的资金以及一些储备金。 币安通过merkle tree和zk-SNARK（Zero-Knowledge Succinct Non-Interactive Argument of Knowledge，零知识证明）实现PoR 通过使用 zk-SNARK技术方案，加密货币交易所可以证明所有默克尔树树叶节点的余额集（即用户账户余额）构成了交易所公布的用户总资产余额。每个用户都可以轻松访问它的叶节点，因为该节点已包含在流程中。对于每位用户的余额（ 默克尔树的叶节点），币安将确保： 1、每个用户的资产余额都被包含在币安的用户净余额总和里。 2、用户的总净余额大于或等于零。 3、将用户信息更新到叶节点哈希后，默克尔树根的更改是有效的（即，无法伪造信息）。 引用 加密资产在币安钱包间流转的方法和原因 What Is a Crypto Wallet and How to Choose the Right One? 储备金证明","tags":["区块链","交易所","binance"],"categories":["区块链","钱包开发"]},{"title":"HD钱包原理-BIP32、BIP39、BIP44","path":"/2024/05/27/HD钱包/","content":"HD钱包HD Wallet（Hierarchical Deterministic Wallet，分层确定性钱包）是基于[BIP32](bips&#x2F;bip-0032.mediawiki at master · bitcoin&#x2F;bips (github.com))实现的用于管理私钥的工具。 非确定性钱包和确定性钱包非确定性钱包可以参考比特币客户端使用随机生成密钥的方式。 比特币客户端会预先生成100个随机私钥缓存在一个密钥池，从最开始就生成足够多的私钥并且每个密钥只使用一次。这种钱包难以管理、 备份以及导入密钥。非确定性钱包的每一个密钥都需要进行备份，如果钱包不可访问时，没有备份的密钥就会失去其资金的控制权 确定性钱包中通过一个主密钥派生出子密钥，这个主密钥称为种子(seed)。 HD钱包是确定性钱包的一种衍生，HD钱包遵循BIP32标准，它通过seed导出树状结构的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥又可以衍生出一系列孙密钥，以此类推，无限衍生。 与HD钱包相关的BIPBIP32、BIP39和BIP44是Bitcoin Improvement Proposals（比特币改进提案）中定义的三种标准，用于增强比特币和其他加密货币钱包的功能和安全性。 BIP32描述了比特币分层确定性钱包 BIP39描述了助记词的实现 BIP43和BIP44，这两个协议规定了钱包的树结构，即HD 钱包标准路径（主要分析BIP44） BIP32-HD原理BIP32由以下几部分来进行深入： 密钥序列化格式：密钥的数据结构 密钥派生：规定子密钥是如何从父密钥中派生 密钥树：父密钥派生子密钥所形成的树状结构 下面通过理论与代码（golang）相结合的方式去理解BIP32。 BIP32实现代码：go-bip32&#x2F;bip32.go at master · tyler-smith&#x2F;go-bip32 (github.com) 序列化格式：密钥结构BIP32规定密钥的序列化格式包括6个类型： 版本（version）:4 byte，对密钥版本的预定。主网的公钥版本-0x0488B21E，私钥版本-0x0488ADE4（测试网 公钥版本-0x043587CF，私钥版本-0x04358394） 深度（depth）:1 byte，密钥当前的层级。如：主密钥层级为0（0x00），派生的一级子密钥层级为1 （0x01） 父密钥指纹（FingerPrint）:4 byte，父密钥hash值的前四位。主密钥的父指纹为0x00000000 子编号（child number）:4 byte，密钥的索引 链码（chain code）:32 byte，通过HMAC-SHA512计算的得到右32字节 公钥或私钥 （Key）: 33 byte ，通过HMAC-SHA512计算的得到左32字节 123456789type Key struct &#123;\tKey []byte // 33 bytes\tVersion []byte // 4 bytes\tChildNumber []byte // 4 bytes\tFingerPrint []byte // 4 bytes\tChainCode []byte // 32 bytes\tDepth byte // 1 bytes\tIsPrivate bool // unserialized&#125; 密钥派生：生成子密钥过程密钥派生有很多种方式推导密钥，比如：父私钥→子私钥、父公钥→子公钥、父私钥→子公钥以及一种不可行的方式，父公钥→子私钥。下面从父私钥推导子公钥的过程进行描述 扩展密钥用于计算子密钥的一部分 将256位的私钥或公钥扩展为512位的位串，将左256表示为k, 右256位表示为c，得到扩展密钥 （k，c）。其中，k是密钥序列化中的key，c是链码 强化密钥得到密钥的种类，有根据给的索引大小区分普通密钥和强化密钥 为什么需要强化密钥（强化派生）：当黑客拿到你的未硬化的扩展子私钥和扩展父公钥（链码）可以反向推导出父私钥或者所有的姊妹钱包，从而盗取你账户的所有资产 细节深入：HD Wallets: Why Hardened Derivation Matters? | by Blaine Malone | Medium 每个扩展密钥有 2 31个普通子密钥， 2 31个强化子密钥（hardened child keys）。 这些子密钥都有一个索引。 普通子密钥使用索引0到 2 31-1。 强化子密钥使用索引 2 31 到 2 31-1。 为了简化强化子密钥索引的符号，数字i H表示i + 2 31。 父私钥 → 子私钥 子密钥派生函数（Child key derivation）：CKDprev( (k，c) , i )，其中i是钱包索引，这个索引与构建密钥树有关 输入扩展密钥与索引 i 将CKD中参数传入到HMAC-SHA512计算 判断（k，c）是否是强化密钥，比较i的值：i &gt; 2 31 如果i &gt; &#x3D; 2 31, data &#x3D; 0x00 || k || i （注意：0x00将私钥补齐到33字节长） i &lt; 2 31，data &#x3D; k || i 得到 l &#x3D; CKDprev( (k，c) , i )，l 是一个长度为 512 的位串。将l 分为两部分lL , lR 得到子密钥：Ki &#x3D; (lL + k) mod n 条件： lL &lt; n ，Ki !&#x3D; 0 , len(Ki ) !&#x3D; 32 （否则得到密钥是无效的） 这里的n是指secp256k1标准定义的参数（Integers modulo the order of the curve， 简称：n） 得到子密钥链码：Ci &#x3D; lR 代码分析创建主密钥主密钥通过种子得到，使用hmac函数计算出位串(Key &#x3D;“比特币种子”,Data &#x3D; seed)，取lL 作为子密钥，lR作为链码 12345678910111213141516171819202122232425func NewMasterKey(seed []byte) (*Key, error) &#123;\t// Generate key and chaincode\thmac := hmac.New(sha512.New, []byte(&quot;Bitcoin seed&quot;))\t_, err := hmac.Write(seed)\tintermediary := hmac.Sum(nil)\t// Split it into our key and chain code\tkeyBytes := intermediary[:32]\tchainCode := intermediary[32:]\t// Create the key struct\tkey := &amp;Key&#123; Version: PrivateWalletVersion, ChainCode: chainCode, Key: keyBytes, Depth: 0x0, ChildNumber: []byte&#123;0x00, 0x00, 0x00, 0x00&#125;, FingerPrint: []byte&#123;0x00, 0x00, 0x00, 0x00&#125;, IsPrivate: true,\t&#125;\treturn key, nil&#125; 父私钥推导子密钥用seed生成主密钥后，调用该方法去生成一个子密钥 123456789101112131415161718192021222324252627282930313233343536373839404142// NewChildKey derives a child key from a given parent as outlined by bip32func (key *Key) NewChildKey(childIdx uint32) (*Key, error) &#123;\t// Fail early if trying to create hardned child from public key\tif !key.IsPrivate &amp;&amp; childIdx &gt;= FirstHardenedChild &#123; return nil, ErrHardnedChildPublicKey\t&#125;\tintermediary, err := key.getIntermediary(childIdx)\tif err != nil &#123; return nil, err\t&#125;\t// Create child Key with data common to all both scenarios\tchildKey := &amp;Key&#123; ChildNumber: uint32Bytes(childIdx), ChainCode: intermediary[32:], Depth: key.Depth + 1, IsPrivate: key.IsPrivate,\t&#125;\t// Bip32 CKDpriv\tif key.IsPrivate &#123; childKey.Version = PrivateWalletVersion fingerprint, err := hash160(publicKeyForPrivateKey(key.Key)) if err != nil &#123; return nil, err &#125; childKey.FingerPrint = fingerprint[:4] childKey.Key = addPrivateKeys(intermediary[:32], key.Key) // Validate key err = validatePrivateKey(childKey.Key) if err != nil &#123; return nil, err &#125; // Bip32 CKDpub\t&#125; else &#123; // ...\t&#125;\treturn childKey, nil&#125; 通过扩展密钥计算lL , lR的位串使用HMAC-SHA512算法计算，先要对索引进行比较，密钥是否是强化密钥 123456789101112131415161718192021222324252627func (key *Key) getIntermediary(childIdx uint32) ([]byte, error) &#123;\t// Get intermediary to create key and chaincode from\t// Hardened children are based on the private key\t// NonHardened children are based on the public key\tchildIndexBytes := uint32Bytes(childIdx)\tvar data []byte // FirstHardenedChild = uint32(0x80000000)\tif childIdx &gt;= FirstHardenedChild &#123; data = append([]byte&#123;0x0&#125;, key.Key...)\t&#125; else &#123; if key.IsPrivate &#123; data = publicKeyForPrivateKey(key.Key) &#125; else &#123; data = key.Key &#125;\t&#125;\tdata = append(data, childIndexBytes...)\thmac := hmac.New(sha512.New, key.ChainCode)\t_, err := hmac.Write(data)\tif err != nil &#123; return nil, err\t&#125;\treturn hmac.Sum(nil), nil&#125; 计算Ki使用该公式计算 Ki &#x3D; (lL + k) mod n 1234567891011121314151617func addPrivateKeys(key1 []byte, key2 []byte) []byte &#123;\tvar key1Int big.Int\tvar key2Int big.Int\tkey1Int.SetBytes(key1)\tkey2Int.SetBytes(key2)\tkey1Int.Add(&amp;key1Int, &amp;key2Int)\tkey1Int.Mod(&amp;key1Int, curve.Params().N)\tb := key1Int.Bytes()\tif len(b) &lt; 32 &#123; extra := make([]byte, 32-len(b)) b = append(extra, b...)\t&#125;\treturn b&#125; 钱包结构：HD钱包的路径前面我们通过CKD函数计算出密钥，计算密钥需要两个参数一个是扩展密钥，一个是索引。通过这个索引我们能够沿着一条路径构建出子密钥，比如：构造一个路径为 “m&#x2F;0&#x2F;0&#x2F;1” 的密钥来控制钱包 构造过程，从seed得到主密钥m，通过m去构造路径： CKD( CKD( CKD( m, 0), 0 ), 1) &#x3D; CKD(CKD(m,0), 0)&#x2F;1 &#x3D; CKD(m, 0)&#x2F;0&#x2F;1 &#x3D; m&#x2F;0&#x2F;0&#x2F;1 Source: https://github.com/bitcoin/bips/blob/master/bip-0032/derivation.png BIP39-助记词标准BIP39描述了记助词的实现，主要分为两个部分：生成记助词和将记助词转化为二进制种子 为什么需要记助词：BIP32通过输入一个seed就能输出主密钥和一堆子密钥，我们只需记住seed就能控制钱包，但是对于人类来说记忆一串毫无关联的数字是很困难的。所以BIP39提出通过一组容易记住的单词（或者说一个句子）来用于生成seed。 生成记助词记助词生成过程： 生成一个初始熵（entropy），熵的长度在128~256位且必须为32位的倍数。其中ENT（entropy length）&#x3D; 熵的长度 将初始熵进行SHA256计算，取前 ENT&#x2F;32 位作为校验和（checksum）。其中 CS（checksum length）&#x3D; ENT&#x2F;32 将熵和校验和拼接（校验和附加在熵后），这个串会被分为11位一组，每一组会对应单词表的索引（0-2047），一共有 MS （mnemonic sentence） &#x3D; ( ENT + CS ) &#x2F; 11 组单词 单词表实现：python-mnemonic&#x2F;src&#x2F;mnemonic&#x2F;wordlist&#x2F;english.txt at master · trezor&#x2F;python-mnemonic (github.com) ENT CS ENT + CS MS 128 4 132 12 160 5 165 15 192 6 198 18 224 7 231 21 256 8 264 24 Source: https://github.com/ethereumbook/ethereumbook 记助词生成种子记助词生成seed时需要两个参数：记助词（mnemonic）和盐（salt，也能叫密码，passphrase）。salt能够保护钱包，比如：黑客必须同时获得你的记助词和密码才能拿到生成主密钥的seed 生成seed的过程 向PBKDF2函数输入参数：记助词、盐 PBKDF2函数计算得到一个512位的seed Source: https://github.com/ethereumbook/ethereumbook BIP44-HD钱包路径标准BIP32中描述了HD钱包的结构，其每一层大约有40亿的子密钥和40亿的强化密钥而每一层又能继续衍生下去，这导致钱包里账户的路径近乎是无限的。如果没有一个明确的标准去约束密钥派生的路径，那么更换钱包时就可能出现兼容性问题 强化派生路径表示例子： m&#x2F;1’&#x2F;0’ , 其路径上有 “‘“作为强化派生的标记 路径级别BIP44规定的路径有五个级别 m&#x2F;purpose’&#x2F;coin_type’&#x2F;accout’&#x2F;change&#x2F;address_index purpose：协议BIP44，一般设置为常量44’ (0x8000002C) coin_type：币种类型，比特币为0’ (0x80000000) accout：账户类型，为用户划分不同身份。从0’开始递增 change：钱包地址对外部是否可见，0用于外部链，1用于内部链 index：地址索引，地址从索引0开始按顺序递增编号 引用： https://github.com/the-web3/blockchain-wallet/tree/master/basicWallet [Web3专题(三) 2种钱包之分层确定性钱包（HD Wallet，BIP32，BIP39，BIP44） | 登链社区 | 区块链技术社区 (learnblockchain.cn)](https://learnblockchain.cn/article/7098#实现一个以太坊钱包（符合 BIP-44 标准的路径）) BIP: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki https://github.com/ethereumbook/ethereumbook 吐槽：为什么国内都不喜欢把引用的图源和链接注释出来…","tags":["以太坊","钱包","golang"],"categories":["区块链","钱包开发"]},{"title":"Uniswap-v1介绍和源码分析","path":"/2024/05/20/Uniswapv1介绍和源码分析/","content":"Uniswap介绍介绍引用官方文档的定义 The Uniswap protocol is a peer-to-peer system designed for exchanging cryptocurrencies (ERC-20 Tokens) on the Ethereum blockchain. The protocol is implemented as a set of persistent, non-upgradable smart contracts; designed to prioritize censorship resistance, security, self-custody, and to function without any trusted intermediaries who may selectively restrict access. Uniswap是一个点对点的去中心化加密货币（或者说是符合ERC20协议的货币）交易系统，用户能使用这个交易所自由地完成各种ERC20 token之间或ETH的兑换。 应用链接：https://app.uniswap.org/ 发展历程Uniswap想法诞生：2017年6月22日，Vitalik发表文章《On Path Independence》 Uniswap创世人登场：2017年7月6日，Hayden Adams被西门子解雇，在其朋友Karl Floersch的影响下开始关注以太坊，并学习智能合约开发。 Uniswap-v1面世：2018年，在Hayden Adams与以太坊有关的人士讨论不断完善并在自身努力下，Uniswap-v1版本于11月2日部署到以太坊主网。 Uniswap的发展：自2020年后，Uniswap逐渐推出新的版本从v2到如今处于开发中的v4版本。Uniswap已经成为以太坊上交易量最大的DEX之一。 人物介绍：Hayden Adams ，是 Uniswap 的创始人之一，也是该项目的重要推动者和领导者。Adams 在加利福尼亚州长大，拥有工程和计算机科学的背景。 Adams 在2018年创建了 Uniswap，并在其初期的开发过程中积极参与。他在设计 Uniswap 时采用了自动化市场制造商（AMM）的概念，使得任何人都可以提供流动性，并从交易费中获取收益，而无需依赖传统的市场制造商或中介。 随着 Uniswap 的发展壮大，Adams 的领导和技术指导成为了项目成功的重要因素之一。他致力于推动项目的不断创新和发展，并与团队合作，不断改进 Uniswap 协议，以满足用户和市场的需求。 Adams 的努力和才华使得 Uniswap 成为了全球范围内 DeFi 生态系统中最重要和受欢迎的项目之一，同时也为加密货币和区块链技术的发展做出了重要贡献。 （人物介绍由ChatGPT生成，详细的人物故事和Uniswap的诞生过程可参考《A Short History of Uniswap》） Uniswap-v1原理自动做市商（automated market makers，AMM）在上述Uniswap的发展历程中中介绍到其设计灵感来源于《On Path Independence》，该文章描述了链上做市商的方式——即，AMM。 AMM是组成DeFi生态系统的一部分，它以一个简单的数学公式（恒定乘积公式，Constant Product Formula）为核心实现无许可和自动化的数字资产交易。 流动性（Liquidity）：在AMM中的流动性是指将一种资产转化为另一种资产（这里资产通常是以太坊上的token20代币） 流动性提供者（Liquidity Provider，LP）：LP也可认为是做市商，LP一般会为添加一对代币池子（tokenA与tokenB的交易对）以供交易。LP可以通过向交易者收费牟利（作为提供流动性的补偿和） 恒定乘积公式恒定乘积公式：x*y &#x3D; k x和y代表流动性池中的token的总量 不管交易怎样变化，市场始终无法脱离这条曲线 交易失去token和获得token只与交易前后的状态有关，与交易价格变化路径无关 通过恒定乘积公式我们能计算交易者swap买卖一种token获得另一种token的数量、LP为流动性池子添加流动性和移除流动性获得的Share 这里的share是指实现AMM的合约发行的token，这个token也可以理解为LP为池子的流动性量化体现。计算：share &#x3D; √ ( x * y ) &#x3D; √ k。 LP可以通过添加流动性mint share，通过移除流动性burn share LP取回池中的一定数量的token对（使用移除流动性方法），需要通过恒定乘积公式去burn一定数量的share 添加流动性LP向池中添加流动性，根据添加token对x与y的数量去计算需要mint的share数量。我们需要保证添加流动性时，池中价格保持不变，即p(添加前) &#x3D; x&#x2F;y 等于p(移除后) (x+dx)&#x2F;(y+dy) 交易不管交易者在池中买卖token多少token，始终满足x * y &#x3D; k。我们可以通过该公式计算卖dx计算得到dy 移除流动性当LP想要拿回池中的token对时，需要移除池中的流动性。我们需要确保移除流动时保持价格不变，即p(移除前) &#x3D; x&#x2F;y 等于p(移除后) (x-dx)&#x2F;(y-dy) Uniswap-v1代码Uniswap v1使用vyper语言编写，这里我将使用solidity重构Uniswap的代码对其进行分析 v1的代码有两部分：Exchange和Factory Exchange：Token和ETH代币对，相当与一个池子，能进行添加、移除流动性和uniswap Factory：用与创建新的Toekn与ETH的代币对，也可以查询代币对对应的Exchange Exchangeexchange实现了ERC20标准，该合约通过添加ETH和Token流动性铸造代币，移除流动性销毁代币以获得ETH和Token。（合约铸造铸造代币下文成为LPT）此外合约提供了ETH与Token的代币兑换、Token与ETH的代币兑换、Token与ETH的价格和Token与另一种Token的兑换等方法 添加&#x2F;移除流动性addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) 向资金池添加流动性 min_liquidity：用户期望获得最小的LP代币，如果铸造代币过少交易会回滚 max_tokens：用户提供的最大Token数量，如果计算出花费Token大于这个值交易会回滚 deadline：交易确认时间，交易超过该时限会回滚 代码逻辑： 检查时限是否超过 用户添加ETH和Token数量不能为零 添加流动性有两种情况： 添加流动性：通过添加流动性公式计算出花费Token的数量和能铸造出的LPT，如果花费Token数量大于max_tokens或能铸造出的LPT小于min_liquidity就需要回滚交易 添加初始流动性：池子最初价格有该笔交易决定，铸造的LPT与转移的ETH数量一致，添加的Token数量等于max_tokens 需要将token转移到合约地址（transferFrom） 12345678910111213141516171819202122232425262728293031323334353637383940function addLiquidity( uint256 min_liquidity, uint256 max_tokens, uint256 deadline ) payable external returns (uint256) &#123; require(deadline &gt; block.timestamp, &quot;block time exceeded deadline&quot;); require(msg.value &gt; 0 &amp;&amp; max_tokens &gt; 0, &quot;add token or eth of amount can&#x27;t equal zero&quot;); uint256 total_liquidity = totalSupply(); if (total_liquidity &gt; 0) &#123; require(min_liquidity &gt; 0, &quot;min_liquidity can&#x27;t equal zero&quot;); // eth_reserve = x, token_reserve = y uint256 eth_reserve = address(this).balance - msg.value; uint256 token_reserve = token.balanceOf(address(this)); // token_amount = dy = dx/x * y + 1 uint256 token_amount = msg.value * token_reserve / eth_reserve + 1; // eth_amount = S = dx/x * T uint256 liuiqity_minted = msg.value * total_liquidity / eth_reserve; require(max_tokens &gt; token_amount, &quot;max_token does not meet the addLiquidity requirement&quot;); require(liuiqity_minted &gt; min_liquidity, &quot;min_liquidity does not meet the addLiquidity requirement&quot;); // mint liquidity _mint(msg.sender, liuiqity_minted); require(token.transferFrom(msg.sender, address(this), token_amount), &quot;transferFrom failed&quot;); emit AddLiquidity(msg.sender, msg.value, token_amount); return liuiqity_minted; &#125; else &#123; require(msg.value &gt;= 1000000000, &quot;init_liquidity must input 1 ether&quot;); require(factory.getExchange(address(token)) == address(this), &quot;factory not create the pair&quot;); uint256 token_amount = max_tokens; // initial liquidity = x wei uint256 initial_liquidity = address(this).balance; // mint liquidity _mint(msg.sender, initial_liquidity); require(token.transferFrom(msg.sender, address(this), token_amount), &quot;transferFrom failed&quot;); emit AddLiquidity(msg.sender, msg.value, token_amount); return initial_liquidity; &#125; &#125; removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline)向资金池移除流动性 amount：想要销毁LPT数量 min_eth：用户最少能取出的ETH数量，如果能取出的最小ETH小于该值，交易会回滚 min_tokens：用户最少能取出的Token数量，如果能取出的最小Token小于该值，交易会回滚 deadline：交易确认时间，交易超过该时限会回滚 代码逻辑与添加流动性类似 检查输入参数是否满足条件，amount，min_eth，min_tokens大于零，当前时间没有时限。 计算给定销毁shares能够取出多少Token和ETH 检查取出的Token和Eth是否满足最小期望 1234567891011121314151617181920212223242526function removeLiquidity( uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline ) payable external returns (uint256 eth_amount, uint256 token_amount) &#123; require(amount &gt; 0, &quot;removeLiquidity must greater than zero&quot;); require(deadline &gt; block.timestamp, &quot;block time exceeded deadline&quot;); require(min_eth &gt; 0 &amp;&amp; min_tokens &gt; 0, &quot;add token or eth of amount can&#x27;t equal zero&quot;); uint256 total_liquidity = this.totalSupply(); require(total_liquidity != 0, &quot;total_liquidity equal zero&quot;); uint256 token_reserve = token.balanceOf(address(this)); // eth_amount = dx = x * S / T eth_amount = address(this).balance * amount / total_liquidity; // token_amount = dy = y * S / T token_amount = token_reserve * amount / total_liquidity; require(eth_amount &gt; min_eth &amp;&amp; token_amount &gt; min_tokens, &quot;min_token or min_tokens does not meet the removeLiquidity requirement&quot; ); // burn liquidity _burn(msg.sender, amount); payable(msg.sender).transfer(amount); require(token.transfer(msg.sender, token_amount), &quot;transferFrom failed&quot;); emit RemoveLiquidity(msg.sender, eth_amount, token_amount); &#125; 价格查询基础 getInputPrice(uint256 input_amount, uint256 input_reserve, uint256 output_reserve) -&gt; uint256 123456789101112131415161718function getInputPrice( uint256 input_amount, uint256 input_reserve, uint256 output_reserve ) private view returns (uint256) &#123; require(input_reserve &gt; 0 &amp;&amp; output_reserve &gt; 0, &quot;input or output equal zero&quot;); // fee &lt; 1000, not write require logic uint256 input_amount_with_fee = 1 wei; input_amount_with_fee = input_amount * (1000 - fee); uint256 numrator = input_amount_with_fee * output_reserve; uint256 denominator = ( input_reserve * 1000 ) + input_amount_with_fee; // dy = y * dx * (1000-fee) / (x * 1000 + dx * (1000 -fee)) return numrator / denominator; &#125; getOutputPrice(output_amount: uint256, input_reserve: uint256, output_reserve: uint256) -&gt; uint256 12345678910111213function getOutputPrice( uint256 output_amount, uint256 input_reserve, uint256 output_reserve ) private pure returns (uint256) &#123; require(input_reserve &gt; 0 &amp;&amp; output_reserve &gt; 0, &quot;input or output equal zero&quot;); uint256 numrator = input_reserve * output_amount * 1000; uint256 denominator = (output_reserve - output_amount) * 997; return numrator / denominator + 1; &#125; 以上面两个函数为基础得到计算eth与toekn之间的价格 getEthToTokenInputPrice(eth_sold: uint256(wei)) -&gt; uint256: 输入要卖出的ETH数量，返回能得到的token数量 getEthToTokenOutputPrice(tokens_bought: uint256) -&gt; uint256(wei):输入要买的token数量，返回需要给出的ETH数量 getTokenToEthInputPrice(tokens_sold: uint256) -&gt; uint256(wei):输入要卖的token数量，返回得到的token数量 getTokenToEthOutputPrice(eth_bought: uint256(wei)) -&gt; uint256输入得到的ETH数量，返回需要的token数量 兑换exchange的其他函数包括有：ETH与Token的兑换、Token与ETH的兑换、Token与Token之间的兑换 代码通过内部ethToTokenInput、ethToTokenOutput、tokenToEthOutput等函数兑换逻辑，一般先获得可以买&#x2F;卖的代币&#x2F;eth数量，确认能获得预期数量的token&#x2F;eth，然后进行转账交易 ETH与Token的兑换 ethToTokenSwapInput ethToTokenTransferInput ethToTokenOutput ethToTokenSwapOutput Token与ETH的兑换 tokenToEthSwapInput tokenToEthTransferInput tokenToEthSwapOutput tokenToEthTransferOutput Token与Token之间的兑换 tokenToTokenSwapInput tokenToTokenTransferInput tokenToTokenSwapOutput tokenToTokenTransferOutput tokenToExchangeSwapInput tokenToExchangeTransferInput tokenToExchangeSwapOutput tokenToExchangeTransferOutput Factoryfactory通过createExchange创建exchange，一个代币创建一个exchange 1234567891011function createExchange(address token) public returns(address) &#123; require(token != address(0)); require(token_to_exchange[token] == address(0)); Exchange exchange = new Exchange(token, 3); token_to_exchange[token] = address(exchange); exchange_to_token[address(exchange)] = token; uint256 token_id = tokenCount + 1; id_to_token[token_id] = token; emit NewExchange(token, address(exchange)); return address(exchange); &#125; 参考资料 梁培利的个人空间-梁培利个人主页-哔哩哔哩视频 (bilibili.com) Uniswap V1 原理与源码解析: https://juejin.cn/post/7172903744147980325 Uniswap源码仓库：https://github.com/Uniswap/v1-contracts 重构源码仓库地址：https://github.com/Salbt/Uniswap-v1-solidity","tags":["uniswap","defi","code"],"categories":["区块链","Uniswap"]},{"title":"Maker协议介绍","path":"/2024/05/12/Maker-Introduce/","content":"DAI稳定币：由于比特币、以太坊这些加密货币的价值波动太大，不能在正常生活中作为现金使用。所以需要一些具有稳定价值的加密货币进行日常的交易和使用。 稳定币有三种类型：基于法定货币抵押的稳定比，如：USDT、USDC。基于加密资产超额抵押的稳定比，如：DAI。基于算法的稳定币，如：AMPL *USDT的中心性，因为其代码包括对用户账户拉入黑名单，甚至进一步进行销毁账户持有USDT的操作 DAI是一种稳定币，能与美元（货币）进行等值兑换， 通过抵押数字资产发行，能与美元（货币）进行等值兑换。1$ &#x3D; 1DAI。 相关概念SCD（Single-Collateral DAI, SCD）：SCD是单担保DAI，早期DAI系统只支持eth作为担保资产，现在已经支持多担保DAI（MCD） MakerDAO ：MakerDAO是Maker系统的去中心化自治组织，MakerDAO的治理者们使用MKR参与系统的维护和DAI的管理 Maker： Maker是以太坊上的智能合约平台，能够通过CDP、自动化反馈机制和适当的外部激励手段支持并稳定DAI价格 MRK是Maker协议治理代币，MKR的持有者通过执行投票（Executive Voting）和治理投票（Governance Polling）对Maker系统进行治理。MKR的持有者还可以通过Maker的运营中获得利润 投票会锁定MRK代币，一票等于一个MKR代币（MKR持有者可以将MKR存入投票合约以获得投票权重） Maker Vault是合约用于质押资产生成DAI代币的智能合约机制，DAI用户可以通过向中介（交易所）购买或质押资产得到DAI CDP（Collateralized Debt Positions, CDP）——抵债仓库： 保存用户所存储的抵债资产，并允许用户生成DAI，一旦生成DAI就代表生成例一笔债务。 CDP会锁定资产，知道用户偿还DAI后才可以拿回资产。CDP能够进行超额抵押，可完成像杠杆的金融操作 DSR（DAI Savings Rate，DSR）：DAI 存款利率，通过将用户持有的DAI锁入Maker协议的DSR合约就可以获得额外的DAI收益 Maker协议DAI也是加密货币的一种，用户可以使用ETH或Bitcoin抵押兑换DAI代币。为了保证1 DAI能兑换1 $，DAI设计者对DAI设计了一系列机制来确保DAI的稳定 Vault——Maker抵押仓库过程： 用户向Maker发送交易创建CDP，然后充值一定数量的抵押品（ETH, Bitcoin） Vault所有者可以生成一笔交易，在交易中通过调整CPD（中的抵押率）选择需要生成的DAI数量 取回自己的抵押品，需要使用 DAI（赎回费用）+ Stability Fee（手续费），手续费需要使用DAI支付 用户支付了一定DAI后，用户就能发送一个交易给MKR并取回所有抵押资产 DAI的抵押案例 Maker清算机制1.当ETH升值时 ​\t用户能够获得更多抵押DAI 2.当ETH贬值时 在DAI中会有keeper对市场进行监控，如果抵押率超过的安全区就会触发清算 用户CPD设置为300%，DAI市场安全区在150%，当CPD小于150%就会触发清算 ​\t用户面临清算会以下面三个步骤进行： Collateral Auction（抵押品拍卖） Debt Auction（债务拍卖） Surplus Auction（盈余拍卖） Maker协议会根据清算率去对用户的vault当前的价值进行判断。每个类型的vault都有各自的清算率，MKR持有者可以通过投票来进行调整 面临清算前有两种方式可以避免：一是可以抵押更多的ETH，二是偿还部分DAI的债务 Collateral Auction当用户面临清算时不采取任何措施就会触发Collateral Auction。该机制会将用户的质押品进行拍卖（通过Maker的拍卖机制），拍卖得到的DAI会用于偿还债务。 如果拍卖得到的DAI多于清算罚金（Penalty Fee），还会触发反向担保品竞拍（Reverse Collateral Auction），将除去清算罚金后的DAI返还给用户。如果拍卖得到的DAI不足以偿还，债务就会由Maker解决 拍卖获取的DAI会立马用于偿还债务，这部分DAI会被销毁 Debt Auction在拍卖得到的DAI不足以偿还债务时，亏损会由Maker承担。Maker会有一个专门用于处理该亏损的缓冲金池子（Maker Buffer）。 如果Maker Buffer没有足够的DAI，Maker协议会触发Debt Auction。 Debt Auction会mint新的MKR代币，这些MKR通过DAI作为货币进行拍卖。拍卖得到的DAI会流入Maker Buffer Surplus Auction竞拍和稳定费的DAI都会流入Maker buffer中，Maker buffer会有一个上限。当Maker Buffer的DAI超过这个上限，就会触发Surplus Auction 。 即，MKR持有者可以使用MRK去竞拍固定数量的DAI。当Surplus Auction结束时，Maker协议会销毁掉拍卖所得的MRK从而减少MRK的供应量 MakerDAO Maker协议的外部参与者Maker协议的运作需要依靠各种外部参与者：Keeper、Oracle、Global Settler和Maker社区成员 Keeper——看护者keeper通常是独立的参与者，他们会在套利机制下为去中心化系统提供流动性。比如，在DAI价格低于1$时，他们会将其买入；在DAI价格高于1$时，他们会将其卖出。Keeper的行为会帮助DAI维持在1$左右。Keeper也会参与Collateral Auction、Debt Auction、Surplus Auction Oracle——预言机Maker协议需要实时地了解到市场上的担保物价值，从而能够知道何时触发清算机制。Oracle就是能够提供实时的信息的对象。 Maker 协议的内部担保物价格来自去中心化信息输入架构（decentralized Oracle infrastructure） 。该架构由大量名为 “喂价机（Oracle Feed）” 的独立节点组成。MKR 投票者选出一组可信赖的喂价节点，并由通过以太坊交易向 Maker 系统提供价格信息。群组的节点数量也是由 MKR 投票者来控制的。 Global Settler——全局清算者Global Settler也叫Emergency Oracle。他是由MRK持有者投票选举出来的，是为了在Maker协议遭到破坏（治理流程或Oracle被攻击）而导致重大损失的策略。 Global Settler拥有冻结单个Oracle，触发紧急关停机制（Emergency Shutdown）的权力。 MKR治理代币Maker协议是双币模型，协议使用DAI作为稳定代币，MKR作为Maker的治理代币。 MKR holder能够参与投票去修改Maker协议。Maker协议面临一些紧急情况时，这些holder能触发关停机制。 MKR 持有者可以对以下事项进行票决： 引入新的担保物类型，并为其设置一组风险参数 修改、乃至增加一种或多种现有担保物资产类型的风险参数 修改 DAI 存款利率 选出喂价机节点群组 选出紧急信息输入者群组 触发紧急关停 升级系统 对MKR holder的激励——Maker协议产生的部分收入会用于奖励MKR holder，这些奖励也会影响他们做出对Maker协议有利的决策 MakerDAO的盈利来源和其分配为了了解MakerDAO的来源，我们必须要清楚以下参数 稳定费（Stability Fee）： 稳定费是根据一个金库所生成的 DAI 数量来计算的年利息（对生成 DAI 的用户来说，稳定费率相当于贷款的年化利率 清算罚金（Liquidation Penalty）：清算罚金是当清算发生时，根据金库中未偿还 DAI 的总量向用户收取的额外一笔费用 Maker的盈利收入 Vault生成的DAI所需的稳定费 当用户通过不同的Token生成Vault以获得DAI，都会有一笔Stability Fee，这笔Fee会在vault关闭或清算时进行结算 拍卖清算获得的清算罚金 在用户vault清算后，需要向maker系统支付一笔Liquidation Penalty + Stability Fee RWAs（Real World Asserts）,购买现实世界的资产以获取收益；如，美国国债等 RWAs现在成为了Maker利息的主要收入 让我用 Clydesdale 举个例子。本质上，Clydesdale 建立一个 SPV 并从 Maker 借入 DAI。然后此 DAI 通过 PSM 兑换为 USDC，并兑换成美元现金。这些美元现金然后用于购买国债，国债由 SPV 持有，作为借入 DAI 的抵押品。Clydesdale 从管理 SPV 中赚取少量报酬，剩余的美国国债利息归 Maker。 Maker的盈利分配Maker会将其盈利分配到 DSR，Maker协议的存款合约会将部分盈利支付存款利息 Keeper，参与清算的Keeper会获得部分激励，比如：参与清算启动拍卖（keeper调用dog .bark）的keeper会获得一笔tip + 拍卖抵押品部分DAI MKR holder ：协议盈利也会分配给MKR持有者，协议会将超出协议缓冲金部分的DAI用于回购MKR并将其销毁 参考资料 Maker白皮书 梁培利的个人空间-梁培利个人主页-哔哩哔哩视频 (bilibili.com) https://www.bitget.fit/zh-CN/news/detail/12560603813192 Dai Stats","tags":["DAI","Maker","稳定币"],"categories":["区块链","MakerPotocol"]}]