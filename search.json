[{"title":"对《On Path Independence》的理解","path":"/2024/05/23/对《On-Path-Independence》的理解/","content":""},{"title":"Uniswap-v1介绍和源码分析","path":"/2024/05/20/Uniswapv1介绍和源码分析/","content":"Uniswap介绍介绍引用官方文档的定义 The Uniswap protocol is a peer-to-peer system designed for exchanging cryptocurrencies (ERC-20 Tokens) on the Ethereum blockchain. The protocol is implemented as a set of persistent, non-upgradable smart contracts; designed to prioritize censorship resistance, security, self-custody, and to function without any trusted intermediaries who may selectively restrict access. Uniswap是一个点对点的去中心化加密货币（或者说是符合ERC20协议的货币）交易系统，用户能使用这个交易所自由地完成各种ERC20 token之间或ETH的兑换。 应用链接：https://app.uniswap.org/ 发展历程Uniswap想法诞生：2017年6月22日，Vitalik发表文章《On Path Independence》 Uniswap创世人登场：2017年7月6日，Hayden Adams被西门子解雇，在其朋友Karl Floersch的影响下开始关注以太坊，并学习智能合约开发。 Uniswap-v1面世：2018年，在Hayden Adams与以太坊有关的人士讨论不断完善并在自身努力下，Uniswap-v1版本于11月2日部署到以太坊主网。 Uniswap的发展：自2020年后，Uniswap逐渐推出新的版本从v2到如今处于开发中的v4版本。Uniswap已经成为以太坊上交易量最大的DEX之一。 人物介绍：Hayden Adams ，是 Uniswap 的创始人之一，也是该项目的重要推动者和领导者。Adams 在加利福尼亚州长大，拥有工程和计算机科学的背景。 Adams 在2018年创建了 Uniswap，并在其初期的开发过程中积极参与。他在设计 Uniswap 时采用了自动化市场制造商（AMM）的概念，使得任何人都可以提供流动性，并从交易费中获取收益，而无需依赖传统的市场制造商或中介。 随着 Uniswap 的发展壮大，Adams 的领导和技术指导成为了项目成功的重要因素之一。他致力于推动项目的不断创新和发展，并与团队合作，不断改进 Uniswap 协议，以满足用户和市场的需求。 Adams 的努力和才华使得 Uniswap 成为了全球范围内 DeFi 生态系统中最重要和受欢迎的项目之一，同时也为加密货币和区块链技术的发展做出了重要贡献。 （人物介绍由ChatGPT生成，详细的人物故事和Uniswap的诞生过程可参考《A Short History of Uniswap》） Uniswap-v1原理自动做市商（automated market makers，AMM）在上述Uniswap的发展历程中中介绍到其设计灵感来源于《On Path Independence》，该文章描述了链上做市商的方式——即，AMM。 AMM是组成DeFi生态系统的一部分，它以一个简单的数学公式（恒定乘积公式，Constant Product Formula）为核心实现无许可和自动化的数字资产交易。 流动性（Liquidity）：在AMM中的流动性是指将一种资产转化为另一种资产（这里资产通常是以太坊上的token20代币） 流动性提供者（Liquidity Provider，LP）：LP也可认为是做市商，LP一般会为添加一对代币池子（tokenA与tokenB的交易对）以供交易。LP可以通过向交易者收费牟利（作为提供流动性的补偿和） 恒定乘积公式恒定乘积公式：x*y &#x3D; k x和y代表流动性池中的token的总量 不管交易怎样变化，市场始终无法脱离这条曲线 交易失去token和获得token只与交易前后的状态有关，与交易价格变化路径无关 通过恒定乘积公式我们能计算交易者swap买卖一种token获得另一种token的数量、LP为流动性池子添加流动性和移除流动性获得的Share 这里的share是指实现AMM的合约发行的token，这个token也可以理解为LP为池子的流动性量化体现。计算：share &#x3D; √ ( x * y ) &#x3D; √ k。 LP可以通过添加流动性mint share，通过移除流动性burn share LP取回池中的一定数量的token对（使用移除流动性方法），需要通过恒定乘积公式去burn一定数量的share 添加流动性LP向池中添加流动性，根据添加token对x与y的数量去计算需要mint的share数量。我们需要保证添加流动性时，池中价格保持不变，即p(添加前) &#x3D; x&#x2F;y 等于p(移除后) (x+dx)&#x2F;(y+dy) 交易不管交易者在池中买卖token多少token，始终满足x * y &#x3D; k。我们可以通过该公式计算卖dx计算得到dy 移除流动性当LP想要拿回池中的token对时，需要移除池中的流动性。我们需要确保移除流动时保持价格不变，即p(移除前) &#x3D; x&#x2F;y 等于p(移除后) (x-dx)&#x2F;(y-dy) Uniswap-v1代码Uniswap v1使用vyper语言编写，这里我将使用solidity重构Uniswap的代码对其进行分析 v1的代码有两部分：Exchange和Factory Exchange：Token和ETH代币对，相当与一个池子，能进行添加、移除流动性和uniswap Factory：用与创建新的Toekn与ETH的代币对，也可以查询代币对对应的Exchange Exchangeexchange实现了ERC20标准，该合约通过添加ETH和Token流动性铸造代币，移除流动性销毁代币以获得ETH和Token。（合约铸造铸造代币下文成为LPT）此外合约提供了ETH与Token的代币兑换、Token与ETH的代币兑换、Token与ETH的价格和Token与另一种Token的兑换等方法 添加&#x2F;移除流动性addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) 向资金池添加流动性 min_liquidity：用户期望获得最小的LP代币，如果铸造代币过少交易会回滚 max_tokens：用户提供的最大Token数量，如果计算出花费Token大于这个值交易会回滚 deadline：交易确认时间，交易超过该时限会回滚 代码逻辑： 检查时限是否超过 用户添加ETH和Token数量不能为零 添加流动性有两种情况： 添加流动性：通过添加流动性公式计算出花费Token的数量和能铸造出的LPT，如果花费Token数量大于max_tokens或能铸造出的LPT小于min_liquidity就需要回滚交易 添加初始流动性：池子最初价格有该笔交易决定，铸造的LPT与转移的ETH数量一致，添加的Token数量等于max_tokens 需要将token转移到合约地址（transferFrom） 12345678910111213141516171819202122232425262728293031323334353637383940function addLiquidity( uint256 min_liquidity, uint256 max_tokens, uint256 deadline ) payable external returns (uint256) &#123; require(deadline &gt; block.timestamp, &quot;block time exceeded deadline&quot;); require(msg.value &gt; 0 &amp;&amp; max_tokens &gt; 0, &quot;add token or eth of amount can&#x27;t equal zero&quot;); uint256 total_liquidity = totalSupply(); if (total_liquidity &gt; 0) &#123; require(min_liquidity &gt; 0, &quot;min_liquidity can&#x27;t equal zero&quot;); // eth_reserve = x, token_reserve = y uint256 eth_reserve = address(this).balance - msg.value; uint256 token_reserve = token.balanceOf(address(this)); // token_amount = dy = dx/x * y + 1 uint256 token_amount = msg.value * token_reserve / eth_reserve + 1; // eth_amount = S = dx/x * T uint256 liuiqity_minted = msg.value * total_liquidity / eth_reserve; require(max_tokens &gt; token_amount, &quot;max_token does not meet the addLiquidity requirement&quot;); require(liuiqity_minted &gt; min_liquidity, &quot;min_liquidity does not meet the addLiquidity requirement&quot;); // mint liquidity _mint(msg.sender, liuiqity_minted); require(token.transferFrom(msg.sender, address(this), token_amount), &quot;transferFrom failed&quot;); emit AddLiquidity(msg.sender, msg.value, token_amount); return liuiqity_minted; &#125; else &#123; require(msg.value &gt;= 1000000000, &quot;init_liquidity must input 1 ether&quot;); require(factory.getExchange(address(token)) == address(this), &quot;factory not create the pair&quot;); uint256 token_amount = max_tokens; // initial liquidity = x wei uint256 initial_liquidity = address(this).balance; // mint liquidity _mint(msg.sender, initial_liquidity); require(token.transferFrom(msg.sender, address(this), token_amount), &quot;transferFrom failed&quot;); emit AddLiquidity(msg.sender, msg.value, token_amount); return initial_liquidity; &#125; &#125; removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline)向资金池移除流动性 amount：想要销毁LPT数量 min_eth：用户最少能取出的ETH数量，如果能取出的最小ETH小于该值，交易会回滚 min_tokens：用户最少能取出的Token数量，如果能取出的最小Token小于该值，交易会回滚 deadline：交易确认时间，交易超过该时限会回滚 代码逻辑与添加流动性类似 检查输入参数是否满足条件，amount，min_eth，min_tokens大于零，当前时间没有时限。 计算给定销毁shares能够取出多少Token和ETH 检查取出的Token和Eth是否满足最小期望 1234567891011121314151617181920212223242526function removeLiquidity( uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline ) payable external returns (uint256 eth_amount, uint256 token_amount) &#123; require(amount &gt; 0, &quot;removeLiquidity must greater than zero&quot;); require(deadline &gt; block.timestamp, &quot;block time exceeded deadline&quot;); require(min_eth &gt; 0 &amp;&amp; min_tokens &gt; 0, &quot;add token or eth of amount can&#x27;t equal zero&quot;); uint256 total_liquidity = this.totalSupply(); require(total_liquidity != 0, &quot;total_liquidity equal zero&quot;); uint256 token_reserve = token.balanceOf(address(this)); // eth_amount = dx = x * S / T eth_amount = address(this).balance * amount / total_liquidity; // token_amount = dy = y * S / T token_amount = token_reserve * amount / total_liquidity; require(eth_amount &gt; min_eth &amp;&amp; token_amount &gt; min_tokens, &quot;min_token or min_tokens does not meet the removeLiquidity requirement&quot; ); // burn liquidity _burn(msg.sender, amount); payable(msg.sender).transfer(amount); require(token.transfer(msg.sender, token_amount), &quot;transferFrom failed&quot;); emit RemoveLiquidity(msg.sender, eth_amount, token_amount); &#125; 价格查询基础 getInputPrice(uint256 input_amount, uint256 input_reserve, uint256 output_reserve) -&gt; uint256 123456789101112131415161718function getInputPrice( uint256 input_amount, uint256 input_reserve, uint256 output_reserve ) private view returns (uint256) &#123; require(input_reserve &gt; 0 &amp;&amp; output_reserve &gt; 0, &quot;input or output equal zero&quot;); // fee &lt; 1000, not write require logic uint256 input_amount_with_fee = 1 wei; input_amount_with_fee = input_amount * (1000 - fee); uint256 numrator = input_amount_with_fee * output_reserve; uint256 denominator = ( input_reserve * 1000 ) + input_amount_with_fee; // dy = y * dx * (1000-fee) / (x * 1000 + dx * (1000 -fee)) return numrator / denominator; &#125; getOutputPrice(output_amount: uint256, input_reserve: uint256, output_reserve: uint256) -&gt; uint256 12345678910111213function getOutputPrice( uint256 output_amount, uint256 input_reserve, uint256 output_reserve ) private pure returns (uint256) &#123; require(input_reserve &gt; 0 &amp;&amp; output_reserve &gt; 0, &quot;input or output equal zero&quot;); uint256 numrator = input_reserve * output_amount * 1000; uint256 denominator = (output_reserve - output_amount) * 997; return numrator / denominator + 1; &#125; 以上面两个函数为基础得到计算eth与toekn之间的价格 getEthToTokenInputPrice(eth_sold: uint256(wei)) -&gt; uint256: 输入要卖出的ETH数量，返回能得到的token数量 getEthToTokenOutputPrice(tokens_bought: uint256) -&gt; uint256(wei):输入要买的token数量，返回需要给出的ETH数量 getTokenToEthInputPrice(tokens_sold: uint256) -&gt; uint256(wei):输入要卖的token数量，返回得到的token数量 getTokenToEthOutputPrice(eth_bought: uint256(wei)) -&gt; uint256输入得到的ETH数量，返回需要的token数量 兑换exchange的其他函数包括有：ETH与Token的兑换、Token与ETH的兑换、Token与Token之间的兑换 代码通过内部ethToTokenInput、ethToTokenOutput、tokenToEthOutput等函数兑换逻辑，一般先获得可以买&#x2F;卖的代币&#x2F;eth数量，确认能获得预期数量的token&#x2F;eth，然后进行转账交易 ETH与Token的兑换 ethToTokenSwapInput ethToTokenTransferInput ethToTokenOutput ethToTokenSwapOutput Token与ETH的兑换 tokenToEthSwapInput tokenToEthTransferInput tokenToEthSwapOutput tokenToEthTransferOutput Token与Token之间的兑换 tokenToTokenSwapInput tokenToTokenTransferInput tokenToTokenSwapOutput tokenToTokenTransferOutput tokenToExchangeSwapInput tokenToExchangeTransferInput tokenToExchangeSwapOutput tokenToExchangeTransferOutput Factoryfactory通过createExchange创建exchange，一个代币创建一个exchange 1234567891011function createExchange(address token) public returns(address) &#123; require(token != address(0)); require(token_to_exchange[token] == address(0)); Exchange exchange = new Exchange(token, 3); token_to_exchange[token] = address(exchange); exchange_to_token[address(exchange)] = token; uint256 token_id = tokenCount + 1; id_to_token[token_id] = token; emit NewExchange(token, address(exchange)); return address(exchange); &#125; 参考资料 梁培利的个人空间-梁培利个人主页-哔哩哔哩视频 (bilibili.com) Uniswap V1 原理与源码解析: https://juejin.cn/post/7172903744147980325 Uniswap源码仓库：https://github.com/Uniswap/v1-contracts 重构源码仓库地址：https://github.com/Salbt/Uniswap-v1-solidity","tags":["defi","uniswap","code"],"categories":["区块链","Uniswap"]},{"title":"Maker协议介绍","path":"/2024/05/12/Maker-Introduce/","content":"DAI稳定币：由于比特币、以太坊这些加密货币的价值波动太大，不能在正常生活中作为现金使用。所以需要一些具有稳定价值的加密货币进行日常的交易和使用。 稳定币有三种类型：基于法定货币抵押的稳定比，如：USDT、USDC。基于加密资产超额抵押的稳定比，如：DAI。基于算法的稳定币，如：AMPL *USDT的中心性，因为其代码包括对用户账户拉入黑名单，甚至进一步进行销毁账户持有USDT的操作 DAI是一种稳定币，能与美元（货币）进行等值兑换， 通过抵押数字资产发行，能与美元（货币）进行等值兑换。1$ &#x3D; 1DAI。 相关概念SCD（Single-Collateral DAI, SCD）：SCD是单担保DAI，早期DAI系统只支持eth作为担保资产，现在已经支持多担保DAI（MCD） MakerDAO ：MakerDAO是Maker系统的去中心化自治组织，MakerDAO的治理者们使用MKR参与系统的维护和DAI的管理 Maker： Maker是以太坊上的智能合约平台，能够通过CDP、自动化反馈机制和适当的外部激励手段支持并稳定DAI价格 MRK是Maker协议治理代币，MKR的持有者通过执行投票（Executive Voting）和治理投票（Governance Polling）对Maker系统进行治理。MKR的持有者还可以通过Maker的运营中获得利润 投票会锁定MRK代币，一票等于一个MKR代币（MKR持有者可以将MKR存入投票合约以获得投票权重） Maker Vault是合约用于质押资产生成DAI代币的智能合约机制，DAI用户可以通过向中介（交易所）购买或质押资产得到DAI CDP（Collateralized Debt Positions, CDP）——抵债仓库： 保存用户所存储的抵债资产，并允许用户生成DAI，一旦生成DAI就代表生成例一笔债务。 CDP会锁定资产，知道用户偿还DAI后才可以拿回资产。CDP能够进行超额抵押，可完成像杠杆的金融操作 DSR（DAI Savings Rate，DSR）：DAI 存款利率，通过将用户持有的DAI锁入Maker协议的DSR合约就可以获得额外的DAI收益 Maker协议DAI也是加密货币的一种，用户可以使用ETH或Bitcoin抵押兑换DAI代币。为了保证1DAI能兑换1$，DAI设计者对DAI设计了一系列机制来确保DAI的稳定 Vault——Maker抵押仓库过程： 用户向Maker发送交易创建CDP，然后充值一定数量的抵押品（ETH, Bitcoin） Vault所有者可以生成一笔交易，在交易中通过调整CPD（中的抵押率）选择需要生成的DAI数量 取回自己的抵押品，需要使用 DAI（赎回费用）+ Stability Fee（手续费），手续费需要使用DAI支付 用户支付了一定DAI后，用户就能发送一个交易给MKR并取回所有抵押资产 DAI的抵押案例 Maker清算机制1.当ETH升值时 ​\t用户能够获得更多抵押DAI 2.当ETH贬值时 在DAI中会有keeper对市场进行监控，如果抵押率超过的安全区就会触发清算 用户CPD设置为300%，DAI市场安全区在150%，当CPD小于150%就会触发清算 ​\t用户面临清算会以下面三个步骤进行： Collateral Auction（抵押品拍卖） Debt Auction（债务拍卖） Surplus Auction（盈余拍卖） Maker协议会根据清算率去对用户的vault当前的价值进行判断。每个类型的vault都有各自的清算率，MKR持有者可以通过投票来进行调整 面临清算前有两种方式可以避免：一是可以抵押更多的ETH，二是偿还部分DAI的债务 Collateral Auction当用户面临清算时不采取任何措施就会触发Collateral Auction。该机制会将用户的质押品进行拍卖（通过Maker的拍卖机制），拍卖得到的DAI会用于偿还债务。 如果拍卖得到的DAI多于清算罚金（Penalty Fee），还会触发反向担保品竞拍（Reverse Collateral Auction），将除去清算罚金后的DAI返还给用户。如果拍卖得到的DAI不足以偿还，债务就会由Maker解决 拍卖获取的DAI会立马用于偿还债务，这部分DAI会被销毁 Debt Auction在拍卖得到的DAI不足以偿还债务时，亏损会由Maker承担。Maker会有一个专门用于处理该亏损的缓冲金池子（Maker Buffer）。 如果Maker Buffer没有足够的DAI，Maker协议会触发Debt Auction。 Debt Auction会mint新的MKR代币，这些MKR通过DAI作为货币进行拍卖。拍卖得到的DAI会流入Maker Buffer Surplus Auction竞拍和稳定费的DAI都会流入Maker buffer中，Maker buffer会有一个上限。当Maker Buffer的DAI超过这个上限，就会触发Surplus Auction 。 即，MKR持有者可以使用MRK去竞拍固定数量的DAI。当Surplus Auction结束时，Maker协议会销毁掉拍卖所得的MRK从而减少MRK的供应量 MakerDAO Maker协议的外部参与者Maker协议的运作需要依靠各种外部参与者：Keeper、Oracle、Global Settler和Maker社区成员 Keeper——看护者keeper通常是独立的参与者，他们会在套利机制下为去中心化系统提供流动性。比如，在DAI价格低于1$时，他们会将其买入；在DAI价格高于1$时，他们会将其卖出。Keeper的行为会帮助DAI维持在1$左右。Keeper也会参与Collateral Auction、Debt Auction、Surplus Auction Oracle——预言机Maker协议需要实时地了解到市场上的担保物价值，从而能够知道何时触发清算机制。Oracle就是能够提供实时的信息的对象。 Maker 协议的内部担保物价格来自去中心化信息输入架构（decentralized Oracle infrastructure） 。该架构由大量名为 “喂价机（Oracle Feed）” 的独立节点组成。MKR 投票者选出一组可信赖的喂价节点，并由通过以太坊交易向 Maker 系统提供价格信息。群组的节点数量也是由 MKR 投票者来控制的。 Global Settler——全局清算者Global Settler也叫Emergency Oracle。他是由MRK持有者投票选举出来的，是为了在Maker协议遭到破坏（治理流程或Oracle被攻击）而导致重大损失的策略。 Global Settler拥有冻结单个Oracle，触发紧急关停机制（Emergency Shutdown）的权力。 MKR治理代币Maker协议是双币模型，协议使用DAI作为稳定代币，MKR作为Maker的治理代币。 MKR holder能够参与投票去修改Maker协议。Maker协议面临一些紧急情况时，这些holder能触发关停机制。 MKR 持有者可以对以下事项进行票决： 引入新的担保物类型，并为其设置一组风险参数 修改、乃至增加一种或多种现有担保物资产类型的风险参数 修改 DAI 存款利率 选出喂价机节点群组 选出紧急信息输入者群组 触发紧急关停 升级系统 对MKR holder的激励——Maker协议产生的部分收入会用于奖励MKR holder，这些奖励也会影响他们做出对Maker协议有利的决策 MakerDAO的盈利来源和其分配为了了解MakerDAO的来源，我们必须要清楚以下参数 稳定费（Stability Fee）： 稳定费是根据一个金库所生成的 DAI 数量来计算的年利息（对生成 DAI 的用户来说，稳定费率相当于贷款的年化利率 清算罚金（Liquidation Penalty）：清算罚金是当清算发生时，根据金库中未偿还 DAI 的总量向用户收取的额外一笔费用 Maker的盈利收入 Vault生成的DAI所需的稳定费 当用户通过不同的Token生成Vault以获得DAI，都会有一笔Stability Fee，这笔Fee会在vault关闭或清算时进行结算 拍卖清算获得的清算罚金 在用户vault清算后，需要向maker系统支付一笔Liquidation Penalty + Stability Fee RWAs（Real World Asserts）,购买现实世界的资产以获取收益；如，美国国债等 RWAs现在成为了Maker利息的主要收入 让我用 Clydesdale 举个例子。本质上，Clydesdale 建立一个 SPV 并从 Maker 借入 DAI。然后此 DAI 通过 PSM 兑换为 USDC，并兑换成美元现金。这些美元现金然后用于购买国债，国债由 SPV 持有，作为借入 DAI 的抵押品。Clydesdale 从管理 SPV 中赚取少量报酬，剩余的美国国债利息归 Maker。 Maker的盈利分配Maker会将其盈利分配到 DSR，Maker协议的存款合约会将部分盈利支付存款利息 Keeper，参与清算的Keeper会获得部分激励，比如：参与清算启动拍卖（keeper调用dog .bark）的keeper会获得一笔tip + 拍卖抵押品部分DAI MKR holder ：协议盈利也会分配给MKR持有者，协议会将超出协议缓冲金部分的DAI用于回购MKR并将其销毁 参考资料 Maker白皮书 梁培利的个人空间-梁培利个人主页-哔哩哔哩视频 (bilibili.com) https://www.bitget.fit/zh-CN/news/detail/12560603813192 Dai Stats","tags":["DAI","Maker","稳定币"],"categories":["区块链","MakerPotocol"]}]